# Row Level Security

This article introduces [Row Level Security][1] (RLS) and [Policies][2] available since postgreSQL v9.5 ([see Feature Matrix][10]). Row Level Security allow multiple users to manipulate their own rows within a same table without colliding with rows of other users.

**Note:** We stronlgy recommand to read the [article about privileges][100] before dealing with this article. Developped example relies on predefined group and user roles partially ordered by a Hasse Diagram as follow:

![Hasse Diagram](/media/figures/privileges.png)

## Do not be confused

Privileges and Row Level Security both enforces security by limiting access to data, but they are totally distinct concepts:

 - Privileges cope with permissions (`SELECT`, `INSERT`, `EXECUTE`, etc.) granted **on** database objects (`TABLE`, `FUNCTION`, etc.) **to** specific roles;
 - Row Level Security cope with table rows access **on** specific conditions (access can be user oriented, but it is not mandatory).
 
## Row Level Policy

First we create a table where our users will be able to play around:

```sql
-- Become Super User:
SET ROLE airproject;
DROP TABLE IF EXISTS userdata CASCADE;
CREATE TABLE userdata(
    Id          SERIAL     NOT NULL
   ,Ownership   NAME       NOT NULL  DEFAULT(current_user)
   ,UserKey     TEXT       NOT NULL
   ,PRIMARY KEY(Id)
   ,UNIQUE(UserKey)
);
```

And we properly [setup privileges][30] according to our global privileges policy: 

```sql
GRANT CONNECT ON DATABASE airdata TO anybody;

GRANT USAGE ON SCHEMA public TO scientific;
GRANT SELECT ON TABLE userdata TO scientific;

GRANT INSERT, UPDATE ON TABLE userdata TO manager;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO manager;

GRANT ALL ON TABLE userdata TO chief;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO chief;
```

The prior defined Hasse Diagram ensures privileges transitivity because we are working with privilege inheritance. That is for Privileges definition. We have setup what kind of DML statements user can executes on specified objects. But this kind of permission acts at the object level:

 - User capable of select on a table is able to select all rows of this table;
 - User capable of update on a table is able to update all rows of this table, regardless it had inserted or not. 

If we want more fine grained security, we could enable Row Level Security. This feature allows administrator to add, among others, a concept
of **Row Ownership**. Row Level Security is enabled by issuing:

```sql
ALTER TABLE userdata ENABLE ROW LEVEL SECURITY;
```

Now we must define row access policies. With the simple following policy:

```sql
CREATE POLICY userdata_rls ON userdata USING(pg_has_role(Ownership, 'usage'));
```

We can allow user:
 - to have their own rows private;
 - to share their rows with other users by downgrading the ownership to lower group roles it belongs to. 

The [function][20] `pg_has_role` determines if the current user belongs the row ownership. This is the key to allow row sharing between roles that inherit from the same group roles.

## Proof concept

Lets manipulate some data with different users to check if Privileges and Row Level Security are working.

### Data Insertion and Ownership setup

First we endorse the role with highest privileges on table, and we create some records:

```sql
-- Become Chief:
SET ROLE jlandercy;
-- Add private data (by default rows belong to user who created them):
INSERT INTO userdata(UserKey) VALUES ('CO/B001'), ('SO2/B001');
-- Share data with Chiefs (generalization):
INSERT INTO userdata(Ownership, UserKey) VALUES ('chief', 'x0/B001'), ('chief', 'x1/B001');
-- Share data with Managers (generalization and downgrade):
INSERT INTO userdata(Ownership, UserKey) VALUES ('manager', 'NO/B001'), ('manager', 'NO2/B001');
-- Share data with a specific manager:
```

First insertion create private records (only `jlandercy` can manipulate it), later insertions create shared records with lower group roles. User who belong to this groups are able to manipulate it.

Finally, the following insertion fails because function `pg_has_role` is not design to check if roles both inherit from a same role. The function aims to check if a role inherits from another by transitivity.

```sql
INSERT INTO userdata(Ownership, UserKey) VALUES ('cganty', 'NO/B003'), ('cganty', 'NO2/B003');
```
```
ERROR: new row violates row-level security policy for table "userdata"
SQL State: 42501
```

The error above is generated by **Row Level Security**, because:

```sql
SET ROLE jlandercy;
SELECT pg_has_role('cganty', 'usage');
```

Evaluate to `FALSE`.

> Note: Group roles define a Hasse Diagram where we have enforced existence of a minimal and maximal elements. But after addition of user roles into this diagram, there is not maximal elements anymore. Furtermore, we have introduced a partial order, not a total order. Therefore, it is impossible to compare, eg. `cganty` and `jlandercy` together.

Then lets create more records with a lower role:

```sql
-- Become Manager:
SET ROLE cganty;
-- Add private data:
INSERT INTO userdata(UserKey) VALUES ('CO2/B001'), ('NOx/B001');
-- Add shared data (generalization):
INSERT INTO userdata(Ownership, UserKey) VALUES ('manager', 'NO/B002'), ('manager', 'NO2/B002');
-- Add public data (generalization and downgrade)
INSERT INTO userdata(Ownership, UserKey) VALUES ('anybody', 'NO/B004'), ('anybody', 'NO2/B004');
```

And it is impossible to insert records with an unauthorized user:

```sql
SET ROLE obrasseur;
INSERT INTO userdata(UserKey) VALUES ('T/B001'), ('v/B001');
```
```
ERROR: permission denied for relation userdata
SQL State: 42501
```

The error above is generated because user `obrasseur` lacks `INSERT` permission on the table. 

### Data selection

Lets see what happens when different users try to retreive all data stored in table:

First Super User overwrite Row Level Security. 

```sql
-- Super User see all data:
SET ROLE airproject;
SELECT * FROM userdata;
```

therefore it can access the whole content:

|id | ownership | userkey  |
|---|-----------|----------|
|1  | jlandercy | CO/B001  |
|2  | jlandercy | SO2/B001 |
|3  | chief     | x0/B001  |
|4  | chief     | x1/B001  |
|5  | manager   | NO/B001  |
|6  | manager   | NO2/B001 |
|7  | cganty    | CO2/B001 |
|8  | cganty    | NOx/B001 |
|9  | manager   | NO/B002  |
|10 | manager   | NO2/B002 |
|11 | anybody   | NO/B004  |
|12 | anybody   | NO2/B004 |

Then we select data using a role who inherits from `chief`.

```sql
SET ROLE jlandercy;
SELECT * FROM userdata;
```

It can access its own records, and all records owned by group roles it belongs, but not private records from other user (even if those users belongs to same group roles):

| id | ownership | userkey  | 
|----|-----------|----------| 
| 1  | jlandercy | CO/B001  | 
| 2  | jlandercy | SO2/B001 | 
| 3  | chief     | x0/B001  | 
| 4  | chief     | x1/B001  | 
| 5  | manager   | NO/B001  | 
| 6  | manager   | NO2/B001 | 
| 9  | manager   | NO/B002  | 
| 10 | manager   | NO2/B002 | 
| 11 | anybody   | NO/B004  | 
| 12 | anybody   | NO2/B004 | 

Role `jlandercy` does not see rows owned by `cganty`.

Then lets select rows with `cganty` role.

```sql
SET ROLE cganty;
SELECT * FROM userdata;
```

It can access all `manager` and lower group roles but, it cannot access private records or records with higher ownership than `manager` such as `chief`. 

| id | ownership | userkey  | 
|----|-----------|----------| 
| 5  | manager   | NO/B001  | 
| 6  | manager   | NO2/B001 | 
| 7  | cganty    | CO2/B001 | 
| 8  | cganty    | NOx/B001 | 
| 9  | manager   | NO/B002  | 
| 10 | manager   | NO2/B002 | 
| 11 | anybody   | NO/B004  | 
| 12 | anybody   | NO2/B004 | 


Finally, lets select data with user `obrasseur`:

```sql
SET ROLE obrasseur;
SELECT * FROM userdata;
```

There is no private records for this role, and it can only access public rows owned by `anybody`:

| id | ownership | userkey  | 
|----|-----------|----------| 
| 11 | anybody   | NO/B004  | 
| 12 | anybody   | NO2/B004 | 

## Conclusion

This example perfectly illustrates Row Level Security can add an extra layer of security on data access with a simple rule.
Off course complexer rules can be built and they are not to be user oriented.

[1]: https://www.postgresql.org/docs/current/static/sql-createpolicy.html
[2]: https://www.postgresql.org/docs/current/static/ddl-rowsecurity.html
[10]: https://www.postgresql.org/about/featurematrix/
[20]: https://www.postgresql.org/docs/current/static/functions-info.html
[30]: https://www.postgresql.org/docs/current/static/sql-grant.html

[100]: https://github.com/jlandercy/airpg/blob/master/doc/privileges.md
